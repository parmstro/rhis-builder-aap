---

# prepare to generate the installer template and copy it to target
# launch the installer
- name: "Ensure the .ssh directory exists"
  ansible.builtin.file:
    path: "/root/.ssh/"
    state: directory
    owner: "root"
    group: "root"
    mode: "0700"    # required .ssh mode

- name: "Create a key pair if required"
  community.crypto.openssh_keypair:
    path: "/root/.ssh/setup_ed25519"
    type: "ed25519"
    state: present
    group: "root"
    owner: "root"
    mode: "0600"    # required public key mode

- name: "Read the public keys"
  ansible.builtin.slurp:
    path: "/root/.ssh/setup_ed25519.pub"
  register: remote_public_key

# it doesn't really matter if it is an rsa key file or a ed25519 file but the name has to be standard
# for standard commands to pick it up, using our custom name means we have to pass -i to every ssh call

# Stat, delete keys, cleanup authorized_keys
- name: "The .ssh directory should exist"
  ansible.builtin.stat:
    path: "/root/.ssh/authorized_keys"
  register: stat_result

- name: "Create the authorized key file on the aap host if it does not exist"
  when: not stat_result.stat.exists
  ansible.builtin.file:
    path: "/root/.ssh/authorized_keys"
    state: touch
    owner: "root"
    group: "root"
    mode: "0600"

- name: "Add our public key to the authorized key file on the aap host"
  ansible.builtin.blockinfile:
    block: "{{ remote_public_key }}"
    path: "/root/.ssh/authorized_keys"
    state: present
    owner: "root"
    group: "root"
    mode: "0600"

- name: "Test the connection"
  ansible.builtin.command: "ssh -o StrictHostKeyChecking=no {{ ansible_fqdn }} 'echo Killroy_was_here'"
  delegate_to: "{{ groups['platform_installer'][0] }}"
  register: result
  changed_when: result.rc == 0

- name: "Assert we were there"
  ansible.builtin.assert:
    that: result.stdout == "Killroy_was_here"
